<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>synApps quadEM</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      quadEM Driver</h1>
    <h2>
      R6-0</h2>
    <h2>
      December XXX, 2015</h2>
    <h2>
      Mark Rivers, University of Chicago</h2>
  </div>
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Databases">Databases</a>
      <ul>
        <li><a href="#quadEM">quadEM.template</a></li>
        <li><a href="#Plugins">Plugins: NDPluginStats, NDPluginStdArrays, NDFileNetCDF</a></li>
        <li><a href="#quadEM_TimeSeries">quadEM_TimeSeries.template</a></li>
        <li><a href="#fast_pid_control">fast_pid_control.db</a></li>
      </ul>
    </li>
    <li><a href="#Performance">Performance</a></li>
    <li><a href="#Common_Setup">Common Setup</a></li>
    <li><a href="#TetrAMM_Setup">TetrAMM Setup</a></li>
    <li><a href="#AHxxx_Setup">AH401 and AH501 series Setup</a></li>
    <li><a href="#NSLS_EM_Setup">NSLS Electrometer Setup</a></li>
    <li><a href="#APS_EM_Setup">APS Electrometer Setup</a></li>
  </ul>
  <h2 id="Overview">
    Overview</h2>
  <p>
    <b>quadEM</b> supports quad electrometers/picoammeters, typically used for photodiode-based
    x-ray beam position monitors, or split ion chambers. They can also be used for any
    low-current measurement that requires high speed digital input. There is support
    for several models:</p>
  <ol>
    <li>The AH401 series (AH401B, AH401D) and AH501 series (AH501, AH501C, AH501D) picoammeters
      originally designed by <a href="http://ilo.elettra.trieste.it/index.php?page=_layout_prodotto&amp;id=54&amp;lang=en">
        Synchrotron Trieste (elettra)</a>. They are now sold commerically by <a href="http://www.caenels.com/caenels/products.php">
          CAENels</a>. These devices communicate using TCP or UDP over 100 Mbit/s Ethernet
      or high-speed serial. They provide 4-channel current measurements at up to 6510
      Hz (AH501 series) or 1000 Hz (AH401 series).</li>
    <li>The TetrAMM picoammeter sold by <a href="http://www.caenels.com/caenels/products.php">
      CAENels</a>. This device communicates using TCP/IP over 1 Gbit/s Ethernet. It provides
      4-channel current measurements at up to 20 kHz.</li>
    <li>The NSLS Quad Electrometer (called NSLS_EM in this document). This device consists
      of a 4-channel digital electrometer unit with Ethernet communication. The device
      provides 4-channel current measurements at up to 2500 Hz.</li>
    <li>The Quad Electrometer built by <a href="mailto:skross@aps.anl.gov">Steve Ross</a>
      from the APS (called APS_EM in this document). This device consists of a 4-channel
      digital electrometer unit and 2 VME boards. The device provides 2 readings per diode
      at up to 813 Hz.</li>
  </ol>
  <p>
    The AH401 series, NSLS_EM, and APS_EM are based on the same principle of an op-amp
    run as a current amplifier with a large feedback capacitor, and a high resolution
    ADC. The AH501 series and TetrAMM are based on a transimpedance input stage for
    current sensing, combined with analog signal conditioning and filtering stages.
    The AH501C, AH501D, and TetrAMM have an integrated programmable bias supply.</p>
  <p>
    The <b>quadEM</b> software includes asyn drivers and an SNL program that provide
    support for the following:</p>
  <ul>
    <li>Analog input records using the NDPluginStats plugin from the synApps <a href="areaDetector.html">
      areaDetector</a> module. This provides digitally averaged readings of the current,
      sum, difference and position at speeds that are determined by the AveragingTime
      record described below. The quadEM drivers do the callbacks on the asynGenericPointer
      interface for NDArray objects required to use the areaDetector plugins. The NDPluginStats
      module is used to compute the averaged readings. It also provides additional statistics
      including standard deviation, min, max, a histogram of values, time-series of the
      statistics, etc.</li>
    <li>One could also use the standard asynFloat64 device support with ai records and
      scan=I/O Intr, in which case the record would update with every reading from the
      device. This is likely to overwhelm the EPICS IOC if the electrometer is run at
      very fast sampling times.</li>
    <li>Streaming data to disk at the full rate from the device. This is done using the
      file plugins from areaDetector.</li>
    <li>Time series data (like a digital scope) of the current, sum, difference and position
      at speeds up to 20000 Hz (TetrAMM), 6510 Hz (AH501 series), 1000 Hz (AH401 series)
      2500 Hz (NSLS_EM), or 813 Hz (APS_EM). The data is available in standard EPICS waveform
      records, using the drvFastSweep asyn driver from the synApps <a href="mca.html">mca</a>
      module. The time per point can be greater, in which case it does averaging. The
      quadEM drivers do the callbacks on the asynInt32Array interface required to use
      this support.</li>
    <li>FFTs of the time series data, providing the power spectrum of each signal as another
      EPICS waveform record.</li>
    <li>epid (fast feedback). This provides fast feedback via an asyn D/A converter (e.g.
      dac128V), also at speeds up to 20000 Hz, 6510 Hz, 1000Hz, 2500 Hz, or 813Hz. If
      it is run slower it does signal averaging. This support is provided in the synApps
      <a href="www.aps.anl.gov/bcda/synApps/std/std.html">std</a> module. The quadEM drivers
      do the callbacks on the asynFloat64 interface required to use the epid fast feedback
      device support.</li>
  </ul>
  <p>
    The following manuals provide detailed information on these devices:</p>
  <ul>
    <li>APS electrometer: <a href="Electrometer_Users_Guide_01_22_2007.pdf">Electrometer
      Users Guide</a></li>
    <li>AH401B electrometer: <a href="AH401B_UsersManual_V1.0.pdf">AH401B Users Manual</a></li>
    <li>AH401D electrometer: <a href="AH401D_UsersManual_V1.2.pdf">AH401D Users Manual</a></li>
    <li>AH501C electrometer: <a href="AH501C_UsersManual_V1.0.pdf">AH501C Users Manual</a></li>
    <li>AH501D electrometer: <a href="AH501D_UsersManual_V1.3.pdf">AH501D Users Manual</a></li>
    <li>TetrAMM electrometer: <a href="TetrAMM_UsersManual_V1.5.pdf">TetrAMM Users Manual</a></li>
  </ul>
  <p>
    The support is based on asynNDArray driver from areaDetector, which in turn is based
    on asynPortDriver. It consists of a base class <a href="quadEMDoxygenHTML/classdrv_quad_e_m.html">
      (drvQuadEM.cpp)</a> which is device-independent. There are device-dependent classes
    for the TetrAMM (<a href="quadEMDoxygenHTML/classdrv_tetr_a_m_m.html">(drvTetrAMM.cpp)</a>,
    AH401 and AH501 series <a href="quadEMDoxygenHTML/classdrv_a_hxxx.html">(drvAHxxx.cpp)</a>
    and the APS electrometer <a href="quadEMDoxygenHTML/classdrv_a_p_s___e_m.html">(drvAPS_EM.cpp)</a>.
    The EPICS State Notation Language (SNL) program (quadEM_SNL.st) is used to synchronize
    acquisition of time-series data, and to compute FFT power-spectra of the time-series
    data.</p>
  <p>
    The quadEM driver works as follows:</p>
  <ul>
    <li>The data from the device-dependent drivers are first placed into a ring buffer
      whose size is defined in the constructor and configuration function. The driver
      provides 4 current readings. 7 additional values are computed from these 4 values:
      SumX, SumY, SumAll, DiffX, DiffY, PositionX, PositionY. The meanings of X and Y
      are discussed in the geometry section below.</li>
    <li>The PV called AveragingTime determines the time period over which to average the
      readings. The AveragingTime divided by the SampleTime determines the number of samples
      to average, NumAverage_RBV. When this number of samples have been accumulated in
      the ring buffer a separate thread copies them to a set of NDArrays and calls any
      registered plugins. </li>
    <li>There is a separate NDPluginStats plugin loaded for each of the 11 data values.
      This plugin receives an array of dimensions [NumAverage_RBV]. This plugin computes
      not only the mean, but also the standard deviation, histogram of values, etc.</li>
    <li>One of the NDArrays contains all of the data values, and has dimensions [11,NumAverage_RBV].
      This array can be passed to any of the file writing plugins, which can thus stream
      all of the data to disk for arbitrarily long time periods.</li>
    <li>An NDStdArrays plugin is also loaded. This can be used to pass all of the data
      [11,NumAverage_RBV] or any of the individual data arrays to any channel access client.</li>
    <li>The computationally intensive work of calculating the statistics is done in plugins,
      so can be done in different threads (if CallbacksBlock is set to No), each potentially
      running in a separate core on modern CPUs.</li>
    <li>In addition to placing the data from each time point into the ring buffer, the
      driver does callbacks on the asynFloat64 interface for each data value. This is
      typically used for fast feedback support with the epid record. It also does callbacks
      on the asynInt32Array interface, which is typically used for the drvFastSweep support
      in the mca module for time-series acquisition.</li>
  </ul>
  <p>
    Note: For the AH501D firmware version 2.0 fixes two problems with previous versions:</p>
  <ul>
    <li>The NAQ command caused data to be sent immediately, it did not wait for a "TRG
      ON" or "ACQ ON" command as it should.</li>
    <li>The "TRG ON" command sent extra characters on the trailing edge of each gate pulse.
      This would corrupt the data if multiple trigger pulses were received.</li>
  </ul>
  <p>
    The AH501D must be updated to firmware 2.0 for proper operation with quadEM R4-1
    or later.</p>
  <p>
    Prior to R5-0 the quadEM driver assumed the following geometry for the 4 current
    inputs:</p>
  <pre>
             4
             
          1     2
             
             3
  </pre>
  <p>
    The PV for the computed quantities were called Sum12, Sum34, Sum1234, Diff12, Diff34,
    Position12, and Position34. The differences, and hence positions, were computed
    as 2-1 and 4-3, which would correspond to Position12 being positive to the right
    and Position34 being positive up in the above diagram.</p>
  <p>
    For R5-0 two geometries are supported, and the names of the Sum, Diff and Position
    PVs were changed. The computed quantities are called SumX, SumY, SumAll, DiffX,
    DiffY, PositionX, and PositionY.</p>
  <p>
    The first geometry is the same as that illustrated above, and is called Diamond.
    For this geometry only 2 diodes are used for the position calculation in each direction.
    SumX=(1+2), SumY=(3+4), DiffX=(2-1), DiffY=(4-3). This geometry is identical to
    the geometry assumed prior to R5-0. The X diodes are 1&2 rather than 1&3 so that
    it is possible to use just the first 2 inputs on the AH501 series to increase readout
    speed in cases where all 4 diodes are not used. This would not be possible if diodes
    1 and 3 were used for the X calculations.</p>
  <p>
    The second geometry is:</p>
  <pre>

          1     2
       
             
          4     3
  </pre>
  <p>
    This geometry is called Square. For this geometry all 4 diodes are used for the
    position calculation in each direction. SumX=SumY=(1+2+3+4), DiffX=(2+3)-(1+4),
    DiffY=(1+2)-(3+4).</p>
  <p>
    For both geometries SumAll=(1+2+3+4), PositionX=DiffX/SumX, and PositionY=DiffY/SumY.
    X positive is to the right and Y positive is up for both geometries.</p>
  <h2 id="Databases">
    Databases</h2>
  <h3 id="quadEM">
    quadEM.template</h3>
  <p>
    The quadEM.template database provides control of the electrometer using the standard
    asyn device support. <a href="http://cars.uchicago.edu/software/epics/NDPluginStats.html">
      NDStats.template</a> from <a href="http://cars.uchicago.edu/software/epics/areaDetector.html">
        areaDetector</a> provides digitally averaged readings of the current, sum, difference
    and position with user-defined averaging time. It also provides the standard deviation,
    minimum, maximum, and other statistics, including a histogram of array values.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Records in quadEM.template</b></td>
      </tr>
      <tr>
        <th>
          drvInfo string</th>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          Access</th>
        <th>
          Models supported</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          QE_MODEL</td>
        <td>
          $(P)$(R)Model</td>
        <td>
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The model of the electrometer. This is normally determined automatically by the
          driver by reading the firmware version. It can also be specified in the configuration
          command. Values are:
          <ul>
            <li>0: Unknown</li>
            <li>1: APS_EM</li>
            <li>2: AH401B</li>
            <li>3: AH401D</li>
            <li>4: AH501</li>
            <li>5: AH501C</li>
            <li>6: AH501D</li>
            <li>7: TetrAMM</li>
            <li>8: NSLS_EM</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_FIRMWARE</td>
        <td>
          $(P)$(R)Firmware</td>
        <td>
          waveform</td>
        <td>
          asynOctet</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The firmware version of the electrometer. In R6-0 this was changed from a stringin
          record to a waveform record of length 256 because the TetrAMM firmware string is
          longer than 40 characters.</td>
      </tr>
      <tr>
        <td>
          QE_ACQUIRE_MODE</td>
        <td>
          $(P)$(R)AcquireMode<br />
          $(P)$(R)AcquireMode_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Acquire mode. Values are:
          <ul>
            <li>0: Continuous </li>
            <li>1: One-shot </li>
          </ul>
          In continuous mode setting Acquire=1 acquires data continuously until Acquire is
          set back to 0.<br />
          In one-shot mode setting Acquire=1 will acquire a data for a single AveragingTime
          time period. This will result in a single call to the plugins, and thus a single
          set of averaged values. The driver will then set Acquire back to 0. This mode is
          intended for data acquisition, for example with the sscan record. With the AH401
          and AH501 series One-shot works in triggered mode as well. When Acquire is set to
          1 it will wait for the trigger to acquire NumAverage_RBV samples. This may require
          multiple trigger pulses depending on the length of the pulses, the AveragingTime
          and the SampleTime_RBV.<br />
        </td>
      </tr>
      <tr>
        <td>
          QE_ACQUIRE</td>
        <td>
          $(P)$(R)Acquire</td>
        <td>
          busy</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Acquire command. This command turns acquisition from the device on (1) and off (0)
          Since it is a "busy" record the device can be used with the sscan record when AcquireMode=One-shot.<br />
          <b>Important note:</b> Operation in One-shot mode with the sscan record also requires
          that the statistics plugins be set to have CallbacksBlock=Yes so that the driver
          waits for the statistics plugins to compute before it sets Acquire back to 0.
        </td>
      </tr>
      <tr>
        <td>
          QE_READ_FORMAT</td>
        <td>
          $(P)$(R)ReadFormat<br />
          $(P)$(R)ReadFormat_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All except APS_EM and NSLS_EM</td>
        <td>
          Read format from the device. Values are:
          <ul>
            <li>0: Binary </li>
            <li>1: ASCII </li>
          </ul>
          In binary mode the AH401 and AH501 send integer data with no delimiters or terminators.
          This can lead to problems if the data stream is somehow corrupted because there
          is no way to know where one set of readings end and the next set begins. This should
          not happen under normal conditions because the devices use TCP, which guarantees
          retransmission of dropped packets. However, it has been observed to occur. In binary
          mode the TetrAMM sends IEEE 754 double-precision values for each channel, followed
          by a Signalling NaN. The NaN is thus effectively a terminator that can be used to
          synchronize the data stream if it is somehow corrupted, though the driver does not
          currently do this. ASCII mode is robust against the synchronization problem, since
          each reading ends with terminator characters. However, ASCII mode is generally slower.
          On the AH401 ASCII mode appears to be able to do 500 reading/s, which is sufficient
          except for the case when IntegrationTime=.001 and PingPong=Yes. On the AH501 ASCII
          mode ranges from 7 to 10 times slower than binary mode. On the TetrAMM ASCII mode
          requires a minimum value of ValuesPerRead of 500, which limits the update rate to
          200 Hz. In binary mode the minimum value of ValuesPerRead is 5, which is an update
          date of 20 kHz, or 100 times faster than ASCII mode. </td>
      </tr>
      <tr>
        <td>
          QE_RANGE</td>
        <td>
          $(P)$(R)Range<br />
          $(P)$(R)Range_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Range command. This selects the sensitivity of the electrometer (A/D units per nanoamp).<br />
          For the TetrAMM the choices are:
          <ul>
            <li>&plusmn;120uA</li>
            <li>&plusmn;120nA</li>
          </ul>
          For the AH501 series the choices are:
          <ul>
            <li>&plusmn;2.5mA</li>
            <li>&plusmn;2.5uA</li>
            <li>&plusmn;2.5nA</li>
          </ul>
          For the AH401 series this selects the feedback capacitor, which controls the gain
          of the device. There are 8 capacitor choices in units of saturation charge:
          <ul>
            <li>1800 pC</li>
            <li>350 pC</li>
            <li>300 pC</li>
            <li>250 pC</li>
            <li>200 pC</li>
            <li>150 pC</li>
            <li>100 pC</li>
            <li>50 pC</li>
          </ul>
          For the NSLS_EM this selects the feedback capacitor, which controls the gain of
          the device. There are 8 capacitor choices in units of saturation charge:
          <ul>
            <li>350 pC</li>
            <li>300 pC</li>
            <li>250 pC</li>
            <li>200 pC</li>
            <li>150 pC</li>
            <li>100 pC</li>
            <li>50 pC</li>
            <li>12 pC</li>
          </ul>
          For the APS_EM this selects the feedback capacitor, which controls the gain of the
          device. There are 8 capacitor choices:
          <ul>
            <li>External</li>
            <li>17.6 pf</li>
            <li>8.80 pF</li>
            <li>5.87 pF</li>
            <li>4.40 pF</li>
            <li>3.52 pF</li>
            <li>2.93 pF</li>
            <li>2.51 pF</li>
          </ul>
          On the APS_EM all gains except the first External gain use capacitors that are built
          in to the Burr Brown chip. These are quite small capacitors and only cover a narrow
          range, so the gains are quite high, and only rather low currents can be measured
          with them, even at the shortest integration times. The external capacitors can be
          replaced to select the first gain, and boards are normally built with 220 pF external
          capacitors. At APS 13-ID we have used much larger values, 1000 to 5000 pF, because
          the currents from our undulator beam position monitor are large. There are actually
          8 external capacitors: 4 of them control the gain for each input for the "ping"
          channel, and the other 4 control the gain for the "pong" channel. By using one capacitor
          value for the 4 diodes on the ping channel and a different capacitor value for the
          4 diodes on the pong channel, then two user-selectable gains are available. One
          must then select the appropriate channel in the PingPong record, and not use the
          average.</td>
      </tr>
      <tr>
        <td>
          QE_PING_PONG</td>
        <td>
          $(P)$(R)PingPong<br />
          $(P)$(R)PingPong_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH401 series, NSLS_EM, APS_EM</td>
        <td>
          The AH401 series, NSLS_EM, and the APS_EM have 2 input channels, which we call Ping
          and Pong here. This doubles the speed of the unit, because one channel is being
          digitized while the other is integrating. This record selects how the two channels
          are treated.<br />
          On the AH401 series the choices are "Off" (0) and "On" (1). "Off" only returns the
          data from the Ping channel. This reduces noise because only a single integration
          capacitor is used, but it reduces the data rate by a factor of two, because data
          are only returned on every other integration time. "On" returns the data from both
          channels, which doubles the data rate at some expense in noise.<br />
          On the NSLS_EM and APS_EM both values are always transmitted from the device. On
          the APS_EM and the choices are #1 (Ping), #2 (Pong), and Avg. which averages the
          values from the Ping and Pong channels. Note that if Range=External and the two
          external capacitors are different, then one should not use Avg. because that will
          mix data from two different gains. On the NSLS_EM and the choices are Phase0, Phase1,
          and Both. These are really the same as the choices on the APS_EM, but using the
          nomenclature that the NSLS_EM documentation uses.</td>
      </tr>
      <tr>
        <td>
          QE_INTEGRATION_TIME</td>
        <td>
          $(P)$(R)IntegrationTime<br />
          $(P)$(R)IntegrationTime_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          AH401 series, NSLS_EM, APS_EM</td>
        <td>
          Selects the integration time of the amplifier. As the integration time is increased
          the sensitivity increases, but the number of readings/sec sent from the device is
          decreased.<br />
          For the AH401 series values range from 0.001s to 1.000s. The data are sent after
          one integration time if PingPong="On" or after 2 integration times if PingPong="Off".<br />
          For the NSLS_EM the values range from .0004s to 1.0 s. Both the Phase0 (Ping) and
          Phase1 (Pong) values are sent at after a time period equal to IntegrationTime *
          ValuesPerRead.<br />
          For the APS_EM the values range from .000615s to 0.1311s. The data are sent to the
          VME card from the amplifier after 2 integration times, one value in the Ping channel
          and one value in the Pong channel. The data period is thus 0.00123 to 0.02622 s,
          or a frequency range of about 813 Hz to 38.1 Hz. </td>
      </tr>
      <tr>
        <td>
          QE_NUM_CHANNELS</td>
        <td>
          $(P)$(R)NumChannels<br />
          $(P)$(R)NumChannels_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM and AH501 series</td>
        <td>
          Selects the number of channels to measure and transmit data for. Using fewer than
          4 channels increases the sampling rate. Allowed choices are:
          <ul>
            <li>1: channel 1 only</li>
            <li>2: channels 1 and 2 only</li>
            <li>4: channels 1-4</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_GEOMETRY</td>
        <td>
          $(P)$(R)Geometry<br />
          $(P)$(R)Geometry_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Selects the geometry of the current inputs as discussed above. Allowed choices are:
          <ul>
            <li>0: Diamond</li>
            <li>1: Square</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_RESOLUTION</td>
        <td>
          $(P)$(R)Resolution<br />
          $(P)$(R)Resolution_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501 series</td>
        <td>
          Selects the resolution of the ADC in bits. Using 16-bits increases the sampling
          rate by a factor of 2 relative to 24-bits. Allowed choices are:
          <ul>
            <li>16: 16-bit data</li>
            <li>24: 24-bit data</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_STATE</td>
        <td>
          $(P)$(R)BiasState<br />
          $(P)$(R)BiasState_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501C and AH501D</td>
        <td>
          Selects the state of the bias supply output voltage. Allowed choices are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_HVS_READBACK</td>
        <td>
          $(P)$(R)HVSReadback</td>
        <td>
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual status of the bias supply output. Possible values are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
          This will stay On for a few seconds after setting BiasState to Off, while the voltage
          is ramped down to 0.</td>
      </tr>
      <tr>
        <td>
          QE_BIAS_INTERLOCK</td>
        <td>
          $(P)$(R)BiasInterlock<br />
          $(P)$(R)BiasInterlock_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM</td>
        <td>
          Selects the state of the bias supply interlock. Allowed choices are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_VOLTAGE</td>
        <td>
          $(P)$(R)BiasVoltage<br />
          $(P)$(R)BiasVoltage_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501C and AH501D</td>
        <td>
          Controls the voltage of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_HVV_READBACK</td>
        <td>
          $(P)$(R)HVVReadback</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual voltage of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_HVI_READBACK</td>
        <td>
          $(P)$(R)HVIReadback</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual current in microamps of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_VALUES_PER_READ</td>
        <td>
          $(P)$(R)ValuesPerRead<br />
          $(P)$(R)ValuesPerRead_RBV</td>
        <td>
          longout<br />
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          On the TetrAMM this record controls the number of readings that are averaged in
          the TetrAMM using the NRSAMP command. The TetrAMM always digitizes at 100 kHz (10
          microseconds per sample). The minimum value of NRSAMP (and hence ValuesPerRead)
          is 5, which means the maximum number of values per second is 20000. Setting ValuesPerRead
          to 100, for example, will average 100 readings in the TetrAMM, and thus result in
          a 1000 values per second sent from the TetrAMM to EPICS.<br />
          <br />
          On the NSLS_EM this record controls the number of readings that are summed in the
          NSLS_EM using the "n" command.<br />
          <br />
          For all other models ValuesPerRead controls the number of values that are read from
          the meter in a single call. These values are averaged in the driver before it does
          any callbacks. The default is 1 (no averaging).
          <br />
          <br />
          Increasing ValuesPerRead will reduce the CPU time because:
          <ul>
            <li>On the TetrAMM and NSLS_EM it reduces the number of readings per second sent,
              from the maximum of 20000, to 100000/ValuesPerRead.</li>
            <li>On the AH401 and AH501 series the driver reduces the frequency of asynOctet-&gt;read()
              calls by a factor of ValuesPerRead, because it can obtain multiple readings from
              the meter in a single call. This is particularly significant on the AH501 series,
              which can transmit up to 26,040 readings per second!</li>
            <li>It reduces the frequency of callbacks to device support.</li>
          </ul>
          The potential disadvantages of larger values for ValuesPerRead are:
          <ul>
            <li>It will change the statistics computed by the NDPluginStats plugin because an
              initial averaging operation has already been performed, which reduces the standard
              deviation, changes the histogram, etc.</li>
            <li>On the NSLS_EM it prevents selecting only Phase0 or Phase1 with the PingPong record.</li>
            <li>It will reduce the sampling frequency of the TimeSeries support</li>
            <li>It will reduce the update frequency of the EPID fast feedback support.</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_SAMPLE_TIME</td>
        <td>
          $(P)$(R)SampleTime_RBV</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the actual time between sample readings from the device. This is controlled
          by the following parameters:
          <ul>
            <li>ValuesPerRead: All models</li>
            <li>IntegrationTime: AH401 series, NSLS_EM, and APS_EM</li>
            <li>PingPong: AH401 series and NSLS_EM</li>
            <li>NumChannels: AH501 series</li>
            <li>Resolution: AH501 series</li>
          </ul>
          The sample time on the TetrAMM is controlled by the following equation:
          <ul>
            <li>10 microseconds * ValuesPerRead.</li>
          </ul>
          The sample time on the AH501 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = 38.4 microseconds * NumChannels * ValuesPerRead</li>
            <li>If Resolution == 24 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time (NumChannels=1, ValuesPerRead=1, Resolution=16) is 38.4
          microseconds, or a sampling frequency of 26.04 kHz. The maximum sample time with
          ValuesPerRead=1, NumChannels=4, Resolution=24 is 307.2 microseconds, or a sampling
          frequency of 3.255 kHz. Setting ValuesPerRead &gt; 1 will increase the sample time
          and reduce the sampling frequency proportionally.<br />
          <br />
          The sample time on the AH401 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = IntegrationTime * ValuesPerRead</li>
            <li>If PingPong == 0 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time is 0.001 seconds, or 1 kHz sampling frequency. The maximum
          sampling time (PingPong=0) is 2 seconds, or 0.5 Hz sampling frequency. Setting ValuesPerRead
          &gt; 1 will increase the sample time and reduce the sampling frequency proportionally.<br />
          <br />
          The sample time on the NSLS_EM is controlled by the following algorithm:
          <ul>
            <li>SampleTime = IntegrationTime * ValuesPerRead</li>
            <li>If PingPong != Both then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time is 0.00041 seconds, or 2.5 kHz sampling frequency. The maximum
          sampling time (PingPong!=Both) is 2 seconds, or 0.5 Hz sampling frequency. Setting
          ValuesPerRead &gt; 1 will increase the sample time and reduce the sampling frequency
          proportionally.<br />
          <br />
          For the APS_EM the sample time is controlled only by ValuesPerRead and the IntegrationTime.
          For ValuesPerRead=1 it ranges from 0.00123 to 0.02622 s, or a sampling frequency
          range of about 813 Hz to 38.1 Hz. Setting ValuesPerRead &gt; 1 will increase the
          sample time and reduce the sampling frequency proportionally.</td>
      </tr>
      <tr>
        <td>
          QE_AVERAGING_TIME</td>
        <td>
          $(P)$(R)AveragingTime<br />
          $(P)$(R)AveragingTime_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Controls the time period over which values are accumulated in the ring buffer before
          they are read out into NDArray objects and any registered plugins are called. AveragingTime
          is actually used to compute NumAverage_RBV=AveragingTime/SampleTime_RBV. The callbacks
          are done when the number of values in the ring buffer equals NumAverage_RBV, and
          exactly NumAverage_RBV values will be passed to the plugins.<br />
          However, setting AveragingTime=0 will set NumAverage_RBV=0 as well, and will disable
          automatic callbacks to areaDetector plugins. In this case data will only be read
          from the ring buffer when the ReadData record is processed. This will read out all
          available data from ring buffer, and the actual number of values read will be NumAveraged_RBV.
          This mode is useful when the quadEM is being used for data acquisition, for example
          in a scan. In this case processing the ReadData record will read all values that
          have accumulated in the ring buffer since ReadData was last processed.</td>
      </tr>
      <tr>
        <td>
          QE_NUM_AVERAGE</td>
        <td>
          $(P)$(R)NumAverage_RBV</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the number of values that will be accumulated in the ring buffer before
          they are read out into NDArray objects and any registered plugins are called. NumAverage_RBV
          is computed as (int)((AveragingTime / SampleTime_RBV) + 0.5).</td>
      </tr>
      <tr>
        <td>
          QE_NUM_AVERAGED</td>
        <td>
          $(P)$(R)NumAveraged_RBV</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the number of values that were actually accumulated in the ring buffer
          before they were read out into NDArray objects and any registered plugins were called.
          If AveragingTime&gt;0 then NumAveraged_RBV will be the same as NumAverage_RBV. However,
          if AveragingTime=0. then NumAverage_RBV=0 and NumAveraged_RBV gives the actual number
          of values read from the ring buffer when the ReadData record was processed.</td>
      </tr>
      <tr>
        <td>
          QE_READ_DATA</td>
        <td>
          $(P)$(R)ReadData</td>
        <td>
          busy</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Writing 1 to this record reads all data from the ring buffer and does the NDArray
          callbacks to all registered plugins. This is typically done when the quadEM is being
          used for data acquisition, for example in a scan. In this case AveragingTime is
          set to 0 and processing the ReadData record will read all values that have accumulated
          in the ring buffer since ReadData was last processed.</td>
      </tr>
      <tr>
        <td>
          QE_RING_OVERFLOWS</td>
        <td>
          $(P)$(R)RingOverflows</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          It is possible for the ring buffer to overflow. The rate at which values are added
          to the ring buffer is controlled by SampleTime_RBV. The rate at which values are
          removed is determined by AveragingTime, or by the rate at which ReadData is processed
          if AveragingTime=0. The size of the ring buffer is determined by the ringBufferSize
          argument to the driver constructor. This defaults to 2048 if it is not specified
          in configuration command in the startup script. If the ring buffer is full when
          the driver tries to add a new value, then the oldest value in the buffer is discarded,
          the new value is added, and RingOverflows is incremented. RingOverflows is set to
          0 the next time the ring buffer is read out. </td>
      </tr>
      <tr>
        <td>
          QE_TRIGGER_MODE</td>
        <td>
          $(P)$(R)TriggerMode</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501 and AH401 series</td>
        <td>
          Controls whether acquisition is free-running ("Internal") or triggered by an external
          pulse ("Ext. Trigger") or an external gate ("Ext. Gate"). All models support "Internal".
          The TetrAMM also supports "Ext. Trigger" and "Ext. Gate". The AH401B supports "Ext.
          Trigger", and the AH501D supports "Ext. Gate". In "Ext. Gate" mode the meter acquires
          data only when the trigger is in the logic high state. This allows it to be controlled
          by a scaler gate output signal, so that the meter is acquiring for the same time
          period as the scaler, for example.</td>
      </tr>
      <tr>
        <td>
          QE_RESET</td>
        <td>
          $(P)$(R)Reset</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Reset command. Processing this record will reset the electrometer. On the APS_EM
          this operation takes about 1 second, and may be required to establish communication
          if the amplifier unit is power-cycled or disconnected and reconnected. On the TetrAMM
          this does a hardware reset of the device, which takes about 10 seconds. On all models
          this operation downloads all of the EPICS settings to the electrometer. The Reset
          reord must be processed if any electrometer is power-cycled without rebooting the
          EPICS IOC.</td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_NAME</td>
        <td>
          $(P)$(R)CurrentName[1-4]</td>
        <td>
          stringin</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          User-defined name to give each of the Current[1-4] inputs. </td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_OFFSET</td>
        <td>
          $(P)$(R)CurrentOffset[1-4]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-3)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from each reading when calculating the Current[1-4].
          The current is calculated as Current = Raw*CurrentScale - CurrentOffset, where Raw
          is the raw value from the device. </td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)ComputeCurrentOffset[1-4]</td>
        <td>
          calcout</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Processing this record will compute a new value of CurrentOffset that will set value
          of the current to 0 under the current conditions. It computes CurrentOffset(new)
          = Current[1-3]:MeanValue_RBV + CurrentOffset(old). This record is provided to convenience
          set the CurrentOffset when the input signal is 0. </td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_SCALE</td>
        <td>
          $(P)$(R)CurrentScale[1-4]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-3)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Scale factor that each reading is multiplied by when calculating the Current[1-4].
          The current is calculated as Current = Raw*CurrentScale - CurrentOffset, where Raw
          is the raw value from the device. This record provides a way to convert the current
          readings into engineering units. All of the models except the TetrAMM transmit integer
          data. This is converted to double precision float for averaging and statistics.
          It is converted back to integer for the time series software, which requires integer
          data. The TetrAMM transmits double precision data in units of amps, so the values
          are typically between 1e-4 to 1e-12. It is convenient to use a CurrentScale of 1e9
          or 1e12, for example, so that the data are displayed in units of nano-amps or pico-amps.
          They are then reasonable sized integers, and the time series software can be used.
        </td>
      </tr>
      <tr>
        <td>
          QE_POSITION_OFFSET</td>
        <td>
          $(P)$(R)PositionOffset[X,Y]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from each reading when calculating the Position[X,Y].
          The position is calculated as Position = Diff/Sum * PositionScale - PositionOffset.
        </td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)ComputePosOffset[X,Y]</td>
        <td>
          calcout</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Processing this record will compute a new value of PositionOffset that will set
          value of the position to 0 under the current conditions. It computes PositionOffset(new)
          = Pos[X,Y]:MeanValue_RBV + PositionOffset(old). This record is provided to convenience
          set the PositionOffset when the position should be defined as 0. </td>
      </tr>
      <tr>
        <td>
          QE_POSITION_SCALE</td>
        <td>
          $(P)$(R)PositionScale[X,Y]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Scale that will be used when calculating the Position[X,Y]. The position is calculated
          as Position = Diff/Sum * PositionScale - PositionOffset.</td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the medm screen to control the quadEM with the records in quadEM.template.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM.adl</h3>
    <img alt="quadEM.png" src="quadEM.png" /></div>
  <h3 id="H1">
    TetrAMM Acquisition Modes</h3>
  <p>
    The TetrAMM can be used in 6 different acquisition modes, depending on the values
    of the TriggerMode and AcquireMode records. The following table describes these
    modes.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="4">
          <b>TetrAMM Acquisition Modes</b></td>
      </tr>
      <tr>
        <th>
          TriggerMode</th>
        <th>
          AcquireMode</th>
        <th>
          Description</th>
        <th>
          TetrAMM commands</th>
      </tr>
      <tr>
        <td>
          Internal</td>
        <td>
          Continuous</td>
        <td>
          Values are acquired continuously and are averaged each time the AveragingTime is
          reached. </td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:OFF</td>
      </tr>
      <tr>
        <td>
          Internal</td>
        <td>
          One-shot</td>
        <td>
          A single set of data is acquired for the AveragingTime and then acquisition stops.
          The plugins will be called only once when the the requested number of samples have
          been received.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=AveragingTime*1e5/ValuesPerRead, TRG:OFF</td>
      </tr>
      <tr>
        <td>
          Ext. Trig.</td>
        <td>
          Continuous</td>
        <td>
          A fixed number of samples is acquired starting on each rising edge of the external
          trigger input. AveragingTime must be set to a value less than the time between trigger
          pulses.</td>
        <td>
          NRSAMP=AveragingTime/1e5, NAQ=0, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Trig.</td>
        <td>
          One-shot</td>
        <td>
          A fixed number of samples is acquired starting on the first rising edge of the external
          trigger input and then acquisition stops. ValuesPerRead must be set to a value less
          than AveragingTime/1e5.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=AveragingTime*1e5/ValuesPerRead, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Gate</td>
        <td>
          Continuous</td>
        <td>
          Samples are acquired while the external trigger input is high. On each falling edge
          of the external trigger signal the plugins are called. ValuesPerRead must be set
          to a value less than (external trigger high time * 1e5).</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Gate</td>
        <td>
          One-shot</td>
        <td>
          Samples are acquired while the external trigger input is high. On the first falling
          edge of the external trigger signal the plugins are called and acquisition stops.
          ValuesPerRead must be set to a value less than (external trigger high time * 1e5).
        </td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
    </tbody>
  </table>
  <h3 id="Plugins">
    Plugins</h3>
  <p>
    The example IOCs provided with quadEM load a file called commonPlugins.cmd, which
    loads the following set of plugins from the areaDetector module. For more information
    see the documentation on <a href="NDPluginStats.html">NDPluginStats</a>, <a href="NDPluginStdArrays.html">
      NDPluginStdArrays</a>, and <a href="NDPluginFile.html#netCDF">NDFileNetCDF</a>.
    Other plugins can also be loaded, for example the TIFF, HDF5 or Nexus file writing
    plugins, etc.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Plugins loaded by commonPlugins.cmd</b></td>
      </tr>
      <tr>
        <th>
          Plugin type</th>
        <th>
          Record prefixes</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          NDPluginStats</td>
        <td>
          $(P)$(R)Current[1-4]:</td>
        <td>
          Statistics for the current values. The average value is $(P)$(R)Current[1-4]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          NDPluginStats</td>
        <td>
          $(P)$(R)Sum[X,Y,All]:</td>
        <td>
          Statistics for the sum of currents 1+2, 3+4, and 1+2+3+4. The average value is $(P)$(R)Sum[X,Y,All]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          NDPluginStats</td>
        <td>
          $(P)$(R)Diff[X,Y]:</td>
        <td>
          Statistics for the differences of current 2-1 and 4-3. The average value is $(P)$(R)Diff[X,Y]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          NDPluginStats</td>
        <td>
          $(P)$(R)Pos[X,Y]:</td>
        <td>
          Statistics for the positions. The average value is $(P)$(R)Pos[X,Y]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          NDPluginStdArrays</td>
        <td>
          $(P)$(R)image1:</td>
        <td>
          Plugin that receives NDArray callbacks of dimension [11,NumAveraged_RBV] and puts
          this data into an EPICS waveform record. This can be used to provide access to all
          of the data from quadEM to any Channel Access client.</td>
      </tr>
      <tr>
        <td>
          NDFileNetCDF</td>
        <td>
          $(P)$(R)netCDF1:</td>
        <td>
          Plugin that receives NDArray callbacks of dimension [11,NumAveraged_RBV] and writes
          this data into a netCDF file. This can be done in Single mode, writing one array
          per file. o It can also be done in Stream mode, which continuously appends arrays
          to a single netCDF file.</td>
      </tr>
    </tbody>
  </table>
  <p>
    Note that the first time the IOC is started all of the plugins will have EnableCallbacks=Disable.
    It is necessary to enable each of the plugins that will be used. The plugins will
    also initially start with CallbacksBlock=No. Setting CallbacksBlock=Yes can reduce
    CPU load on slow processors like the MVME2100 (see the performance tables below).
    The values of EnableCallbacks and CallbacksBlock are saved by autosave, and will
    be restored the next time the IOC is started.</p>
  <p>
    This is the medm screen for all of the plugins defined in commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      QECommonPlugins.adl</h3>
    <img alt="QECommonPlugins.png" src="QECommonPlugins.png" /></div>
  <p>
    This is the medm screen for the Current1: NDPluginStats plugin loaded by commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDStats.adl</h3>
    <img alt="QENDStats.png" src="QENDStats.png" /></div>
  <p>
    This is the medm screen for the netCDF1: NDFileNetCDF plugin loaded by commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDFileNetCDF.adl</h3>
    <img alt="QENetCDF.png" src="QENetCDF.png" /></div>
  <h3 id="quadEM_TimeSeries">
    Time Series</h3>
  <p>
    The quadEM_TimeSeries.template database provides a time-history (like a digital
    scope) of the current, sum, difference and position at speeds up to 20000Hz (TetrAMM),
    6510 Hz (AH501 series), 1000Hz (AH401 series) or 813 Hz (APS_EM). The time per point
    can be greater than the sampling time, in which case it does averaging. It also
    optionally uses FFTs to compute the frequency power-spectrum of each signal. The
    time-series support requires the drvFastSweep driver from the synApps mca module,
    and also the quadEM_SNL SNL program in this quadEM module. The time-series and frequency
    spectra are contained in standard EPICS waveform records.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in quadEM_TimeSeries.template</b></td>
      </tr>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          $(P)$(R)SNL_Connected</td>
        <td>
          bi</td>
        <td>
          Indicates whether the SNL program has successfully connected to all required records
          in quadEM_TimeSeries.template.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseAll</td>
        <td>
          bo</td>
        <td>
          Erases all time-series waveform records.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseStart</td>
        <td>
          bo</td>
        <td>
          Erases and starts time series data acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StartAll</td>
        <td>
          bo</td>
        <td>
          Re-starts acquisition without erasing the data first.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StopAll</td>
        <td>
          bo</td>
        <td>
          Stops time-series data acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Acquiring</td>
        <td>
          busy</td>
        <td>
          Indicates if tacquisition is Done or Acquiring.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)MaxChannels</td>
        <td>
          longin</td>
        <td>
          The maximum number of time-series points that can be acquired. Controlled by the
          value specified when the quadEM_TimeSeries.template file and quadEM_SNL SNL program
          were loaded.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)NuseAll</td>
        <td>
          longout</td>
        <td>
          Controls the number of time-series points to acquire before acquisition stops automatically.
        </td>
      </tr>
      <tr>
        <td>
          $(P)$(R)CurrentChannel</td>
        <td>
          longin</td>
        <td>
          The current time-series data point being acquired.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ReadAll</td>
        <td>
          bo</td>
        <td>
          Forces all the time-series waveform records to process and read the current time-series
          data. This record can be periodically processed to read the time-series data as
          it is being acquired. Even if this record is Passive the time-series data will be
          read once when time-series data acquisition is complete.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Dwell</td>
        <td>
          ao</td>
        <td>
          The dwell time per point. This time is constrained to be an integer multiple of
          the SampleTime, whose range is discussed above. The readback value of $(P)$(R)Dwell_RBV
          gives the actual dwell time per point.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Dwell_RBV</td>
        <td>
          ai</td>
        <td>
          The actual dwell time per point, which may differ from Dwell, because the time per
          point is constrained to be a multiple of the sampling time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ElapsedReal</td>
        <td>
          ao</td>
        <td>
          The elapsed real time since time-series data acquisition started.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)PresetReal</td>
        <td>
          dfanout</td>
        <td>
          The preset real time. Time-series acquisition will stop if this value is reached.
          If this value is 0 then there is no preset real time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)AutoRestartTS</td>
        <td>
          bo</td>
        <td>
          Controls whether time-series data acquisition is automatically restarted as soon
          as it completes. Choices are "No" and "Yes". This can be useful for producing a
          continuously updating display of frequency power-spectra, for example.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Current[1-4]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode currents.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Sum[X,Y,All]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Diff[X,Y]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode differences.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Position[X,Y]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode positions.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)TimeAxis</td>
        <td>
          waveform</td>
        <td>
          An array of the times for the x-axis of time series plots.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ComputeFFT</td>
        <td>
          bo</td>
        <td>
          Controls whether FFTs power-spectra are computed when time-series data acquisition
          completes. Choices are "No" and "Yes". The FFT calculations are done in the SNL
          program using the Numerical Recipes "four1" function.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Current[1-4]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode currents.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Sum[X,Y,All]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Diff[X,Y]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode differences.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Position[X,Y]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode positions.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)FreqAxis</td>
        <td>
          waveform</td>
        <td>
          An array of the frequencies for the x-axis of frequency power-spectrum plots.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EnableClientWait</td>
        <td>
          bo</td>
        <td>
          A flag to control whether time-series data acquisition waits for a client to reset
          the ClientWait record.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ClientWait</td>
        <td>
          busy</td>
        <td>
          A busy record which a client must set back to 0 to enable time-series data acquisition
          to continue if EnableClientWait is "Enable".</td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the medm screen to control the records in quadEM_TimeSeries.template.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_TimeSeries.adl</h3>
    <img alt="quadEM_TimeSeries.png" src="quadEM_TimeSeries.png" /></div>
  <p>
    This is the medm screen for the first 2 channels. It contains the currents, sum
    and position as a function of time. The dwell time was 0.002s, and there are 2048
    channels (time points), so the total time is 4.096 seconds.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_PlotAll.adl</h3>
    <img alt="quadEM_TimeSeriesPlot.png" src="quadEM_TimeSeriesPlot.png" /></div>
  <p>
    This is an medm screen that displays the FFTs of the Current, Sum, and Position
    for the time-series data above.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_plotAll.adl</h3>
    <img alt="quadEM_FFTPlot.png" src="quadEM_FFTPlot.png" /></div>
  <h3 id="fast_pid_control">
    fast_pid_control.db
  </h3>
  <p>
    The quadEM can be used to do fast feedback with the EPID record from the synApps
    "std" module. The EPID record will process at up to the SampleTime discussed above.
    The DT field of the EPID record controls the time between feedback calculations,
    and this is constrained to be an integer multiple N of the quadEM SampleTime. If
    N>1 then N samples are averaged for each feedback operation.
  </p>
  <p>
    This is the medm screen that controls the fast feedback of the pitch of the monochromator
    on APS beamline 13-ID. The readback and control PVs cannot be changed after iocInit.
    The update rate (SCAN rate of EPID record) only controls the rate at which the EPID
    record displays "snapshots" of the values of the input, output, and error. It does
    not affect the rate at which the feedback is actually being done, which is controlled
    by the DT field in the EPID record, can be much faster than the SCAN value.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_control.adl</h3>
    <img alt="quadEM_pid_control.png" src="quadEM_pid_control.png" /></div>
  <p>
    This is the medm screen that controls the PID parameters. These include the feedback
    coefficients KP, KI, and KD. The DT (delta time) field controls the rate at which
    the feedback is actually been run. In this case DT=68.0 ms, which is 55 times longer
    than the sampling time (1.23 ms), so 55 position readings are being averaged each
    time the feedback is run.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_parameters.adl</h3>
    <img alt="quadEM_pid_parameters.png" src="quadEM_pid_parameters.png" /></div>
  <p>
    This is an medm screen that displays the setpoint of the pitch of the monochromator
    (in red), and the actual readback from the quadEM (in blue). Note that the readback
    here is only the snapshot values from the EPID record. For full-speed readings of
    the readback the waveform records from the quadEM_TimeSeries.template database would
    be used.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_plot_readback.adl</h3>
    <img alt="quadEM_plot_readback.png" src="quadEM_pid_plot_readback.png" /></div>
  <p>
    This is pid_fast.template, an example substitutions file. This example uses a quadEM
    asyn port driver named "APS_EM". ICHAN is set to read from addr=9 and 10, which
    are the two position values of the quadEM driver. The INPUT_DATA and INPUT_INTERVAL
    strings are the drvInfo strings for these parameters in the driver. The output is
    sent to an asyn port driver named DAC1, which is a dac128V 12-bit A/D converter
    in this data. OCHAN is set to write to addr=1 and 2, which are the second and third
    DAC channels on that card. The OUTPUT_DATA string is the drvInfo string for the
    double precision data in the dac128V.
  </p>
  <pre>
file "$(STD)/stdApp/Db/fast_pid_control.db"
{
pattern
{P,                 PID,  INPUT,     INPUT_DATA,   INPUT_INTERVAL, ICHAN, OUTPUT, OCHAN,  OUTPUT_DATA,    LOPR,     HOPR,  DRVL,  DRVH,  PREC,   KP,    KI,  KD,   DT,        SCAN}
{quadEMTest:, MonoPitch, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,     9,   DAC1,     1,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
{quadEMTest:,  MonoRoll, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,    10,   DAC1,     2,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
}
</pre>
  <h2 id="Performance">
    Performance</h2>
  <p>
    The following table shows the CPU utilization of a Linux machine (Xeon E5630 2.53GHz),
    vxWorks MVME5100, and vxWorks MVME2100 with the AH501 electometer. The CPU load
    was measured as a function of the parameters that control the SampleTime (ValuesPerRead,
    NumChannels, Resolution). The CPU load also depends on the AveragingTime, since
    that controls the rate of callbacks to the statistics and other plugins. The AveragingTime
    was mostly held constant at 0.1 seconds on vxWorks, but was changed between 0.1
    second and 0.01 seconds on Linux. Measurements were also done with all of the plugins
    set to CallbacksBlock=Yes and CallbacksBlock=No. When CallbacksBlock=No then each
    plugin runs in its own thread. On a multi-core system this can improve performance
    because each plugin runs in its own core. On a single-core system CallbacksBlock=Yes
    can improve performance because a single thread runs all of the the plugin code,
    and thread context switches are avoided.</p>
  <p>
    It can be seen that the load on Linux is less than 10% when the AveragingTime is
    0.1 second, and less than 25% when it is 0.01 second. Tests on a Windows 7 64-bit
    machine (Intel Core i7-2820QM 2.3GHz) gave very similar results to Linux. Note that
    the Linux (and Windows CPU) values listed are the percent of a <b>single</b> CPU
    core. These are 8-core systems, so the percent of the total system CPU is 8 times
    less. The load on the MVME5100 is significant, but it can handle NumChannels=4 with
    ValuesPerRead=1 for either resolution. The MVME2100 on the other hand cannot run
    with ValuesPerRead=1 at all, it completely saturates the system. It does work with
    ValuesPerRead=4 or 10. On the MVME 2100 setting CallbacksBlock=Yes does signficantly
    reduce the CPU load.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Performance of AH501 using TCP</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          ValuesPerRead</th>
        <th>
          NumChannels</th>
        <th>
          Resolution</th>
        <th>
          AveragingTime</th>
        <th>
          CallbacksBlock</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          5%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.01</td>
        <td>
          No</td>
        <td>
          25%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.01</td>
        <td>
          Yes</td>
        <td>
          19%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.01</td>
        <td>
          No</td>
        <td>
          25%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.01</td>
        <td>
          Yes</td>
        <td>
          18%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          7%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          6%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          10%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          8%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          28%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          29%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          22%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          23%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          11%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          32%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          55%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          45%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          65%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          55%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          45%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          31%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          0.2</td>
        <td>
          Yes</td>
        <td>
          22%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          35%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          1</td>
        <td>
          24</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          42%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          46%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          10</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          54%</td>
      </tr>
    </tbody>
  </table>
  <p>
    The following table shows the CPU utilization of the Linux machine, vxWorks MVME5100,
    and vxWorks MVME2100 with the AH401B electometer as a function of the AveragingTime
    and CallbacksBlock at the shortest integration time (0.001 seconds). It can be seen
    that the load on Linux and on the MVME5100 are both less than 10% when AveragingTime=0.1
    second. The MVME2100 uses about 50% of the CPU under these conditions, but increasing
    ValuesPerRead and/or AveragingTime reduces this.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="6">
          <b>Performance of AH401B using TCP</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          ValuesPerRead</th>
        <th>
          IntegrationTime</th>
        <th>
          AveragingTime</th>
        <th>
          CallbacksBlock</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          3%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.01</td>
        <td>
          No</td>
        <td>
          13%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.01</td>
        <td>
          Yes</td>
        <td>
          14%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          7%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          9%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.01</td>
        <td>
          No</td>
        <td>
          56%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.01</td>
        <td>
          Yes</td>
        <td>
          36%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          55%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          50%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.2</td>
        <td>
          No</td>
        <td>
          20%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          0.001</td>
        <td>
          0.2</td>
        <td>
          Yes</td>
        <td>
          15%</td>
      </tr>
    </tbody>
  </table>
  <p>
    The following table shows the CPU utilization of vxWorks MVME5100 and vxWorks MVME2100
    with the APS electometer as a function of the ValuesPerRead, IntegrationTime, AveragingTime,
    and CallbacksBlock. The MVME5100 uses less than 10% of the CPU under the conditions
    measured. The MVME2100 uses almost 70% of the CPU at the fastest sampling time,
    but doubling ValuesPerRead and AveragingTime reduces this to less than 25%.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="6">
          <b>Performance of APS Electometer</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          ValuesPerRead</th>
        <th>
          IntegrationTime</th>
        <th>
          AveragingTime</th>
        <th>
          CallbacksBlock</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          10%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          9%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          5%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          7%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          6%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          5%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          68%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          55%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          2</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          53%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          2</td>
        <td>
          0.0006</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          41%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          No</td>
        <td>
          50%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          0.001</td>
        <td>
          0.1</td>
        <td>
          Yes</td>
        <td>
          40%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          2</td>
        <td>
          0.001</td>
        <td>
          0.2</td>
        <td>
          Yes</td>
        <td>
          22%</td>
      </tr>
    </tbody>
  </table>
  <h2 id="Common_Setup">
    Common Setup</h2>
  <p>
    All of the device-dependent startup scripts invoke <a href="quadEM_commonPlugins_cmd.html">
      quadEM/iocBoot/iocTest/commonPlugins.cmd</a>. This file can be edited to add additional
    plugins, such as the TIFF, HDF5, or Nexus file writers, etc.</p>
  <p>
    The example iocBoot directory, iocBoot/iocTest, contains an example startup script
    for Linux and Windows (st.cmd) and another for vxWorks (st.cmd.vxWorks). Each of
    these startup scripts invokes the device-dependent startup script(s), e.g. TetrAMM.cmd,
    NSLS_EM.cmd, etc.
  </p>
  <h2 id="TetrAMM_Setup">
    TetrAMM Setup</h2>
  <p>
    These meters communicate via IP, so they must be configured with an IP address reachable
    from the host IOC machine. The CAEN ELS Device Manager software must be used to
    configure the device IP address and port number.</p>
  <p>
    An example startup script for Linux or Windows is provided in
    <br />
    <a href="quadEM_cmd_TetrAMM.html">quadEM/iocBoot/iocTest/TetraAMM.cmd</a>
  </p>
  <p>
    This will need to be edited to set the correct IP address of the meter to be used.</p>
  <h2 id="AHxxx_Setup">
    AH401 and AH501 Series Setup</h2>
  <p>
    These meters communicate via IP, so they must be configured with an IP address reachable
    from the host IOC machine. The Lantronix module in the meters can be configured
    to use either UDP or TCP. UDP can reduce CPU load, however it is more susceptible
    to synchronization problems since it does not retransmit dropped packets. The startup
    script must include the UDP qualifier on the drvAsynIPPortConfigure command if UDP
    is selected.</p>
  <p>
    Example startup scripts for Linux or Windows are provided in
    <br />
    <a href="quadEM_cmd_AH401B.html">quadEM/iocBoot/iocTest/AH401B.cmd</a> and
    <br />
    <a href="quadEM_cmd_AH501.html">quadEM/iocBoot/iocTest/AH501.cmd</a>
  </p>
  <p>
    These will need to be edited to set the correct IP address of the meters to be used.</p>
  <p>
    These scripts each invoke a generic script:
    <br />
    <a href="quadEM_cmd_AHxxx.html">quadEM/iocBoot/iocTest/AHxxx.cmd</a>.
  </p>
  <h2 id="NSLS_EM_Setup">
    NSLS_EM Setup</h2>
  <p>
    These meters communicate via IP. They only support DHCP, they cannot be given a
    static IP address. Each module on the subnet must have a unique Module ID, which
    is set by a 16-position rotary switch on the device front panel. The driver sends
    a broadcast message on the subnet to determine the Module ID and current IP address
    of all NSLS_EM modules. If the specified module ID is found then it configures communication
    to that module by calling drvAsynIPPortConfigure internally.</p>
  <p>
    An example startup script for Linux or Windows is provided in
    <br />
    <a href="quadEM_cmd_NSLS_EM.html">quadEM/iocBoot/iocTest/NSLS_EM.cmd</a>
  </p>
  <p>
    This will need to be edited to set the broadcast address of the network the device
    is connected to, and the Module ID of the device.</p>
  <h2 id="APS_EM_Setup">
    APS Electrometer Setup</h2>
  <p>
    The APS_EM VME card cannot generate interrupts, but it can output a TTL pulse each
    time new data is available, at up to 815 Hz. If this pulse is input to an Ip-Unidig
    (or other asyn digital I/O device with interrupt and callback capabilities), then
    the ipUnidig interrupt routine will call the APS_EM driver each time new data is
    available. The Ip-Unidig channel where the APS_EM pulse is connected is specified
    in the unidigChan argument to drvAPS_EMConfigure command in the startup script.
    If an Ip-Unidig or other interrupt source is not being used then the APS_EM driver
    will poll for new data at the system clock rate, typically 60Hz.</p>
  <p>
    An example startup script for vxWorks is provided in
    <br />
    <a href="quadEM_st_cmd_vxWorks.html">quadEM/iocBoot/iocTest/st.cmd.vxWorks</a>.
  </p>
  <p>
    This example startup script can be edited to start either the APS_EM, the TetrAMM,
    the AH401B, or the AH501. For the APS_EM this script invokes
    <br />
    <a href="quadEM_cmd_APS_EM.html">quadEM/iocBoot/iocTest/APS_EM.cmd</a>.
  </p>
</body>
</html>
